{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Customies Docs Table Of Content Custom Item Guides Custom Block Guides Block Permutations Custom Entity Guides Pack Guides Examples Resource Pack CustomiesWikiPack is an example resource pack that implements all the examples found in this wiki. It can also be used as a guide to creating your own. Customies is just a plugin which provides an API for developers to register custom features. Developers are expected to create the resource pack themselves, and should use resources like wiki.bedrock.dev for guides on creating them. For support with the Customies API, you can join our Discord . It's not the official wiki, If you have any doubs, please refer to the Official Wiki Contribute Feel free to submit pull requests to improve or request changes in the documentation.","title":"Home"},{"location":"#welcome-to-customies-docs","text":"","title":"Welcome to Customies Docs"},{"location":"#table-of-content","text":"Custom Item Guides Custom Block Guides Block Permutations Custom Entity Guides Pack Guides","title":"Table Of Content"},{"location":"#examples-resource-pack","text":"CustomiesWikiPack is an example resource pack that implements all the examples found in this wiki. It can also be used as a guide to creating your own. Customies is just a plugin which provides an API for developers to register custom features. Developers are expected to create the resource pack themselves, and should use resources like wiki.bedrock.dev for guides on creating them. For support with the Customies API, you can join our Discord . It's not the official wiki, If you have any doubs, please refer to the Official Wiki","title":"Examples Resource Pack"},{"location":"#contribute","text":"Feel free to submit pull requests to improve or request changes in the documentation.","title":"Contribute"},{"location":"block_permutations/","text":"Block Permutations It is important to note that permutations are a very complex system, at least compared to the rest of the Customies API. For support with the Customies API, you can join our Discord . What are permutations? In Minecraft, permutations are a way for a single block to behave different based on server-side data. Without permutations, a block can only have one possible state and behave similar to a dirt block. With permutations however, you can change the model or rotation of the same block to emulate the behaviour of a crop or a door etc. How do they work? When creating a block with permutations, there are two important sets of data that you must provide. The first is an array of block properties. Each block can have multiple block properties, and each one has a name and an array of all its possible values. The second set of data is an array of permutations which uses the block properties in molang queries to provide different block components for each different state. Both of these are sent to the client so it knows how to render every possible combination of the block. Rotating Blocks Customies includes a built-in RotatableTrait which can be used to implement horizontal rotations for your block. You do not need to write any extra code for it to function, and can easily be followed as an example of how permutations should be created. use customiesdevs\\customies\\block\\permutations\\Permutable; use customiesdevs\\customies\\block\\permutations\\RotatableTrait; use pocketmine\\block\\Opaque; class ExampleBlock extends Block implements Permutable { use RotatableTrait; } Creating Your Own Permutations To get started with adding permutations to your block, you must first implement the Permutable interface. This interface requires you to implement all the methods necessary for permutations to function for a block. To help understand how permutations work, code from RotatableTrait will be used as examples. getBlockProperties() In this method you must return an array of BlockProperty objects which can be used to determine the state of the block. In the example below, it is creating a property called customies:rotation with the possible values of [2, 3, 4, 5] . These numbers are the values from Facing::NORTH , Facing::SOUTH , Facing::WEST & Facing::EAST . The values do not need to be anything specific, and can use any primitive data type. public function getBlockProperties(): array { return [ new BlockProperty(\"customies:rotation\", [2, 3, 4, 5]), ]; } getPermutations() In this method you must return an array of Permutation objects which can override different components based on a condition of the state. In the example below, there are four different permutations which all check for a different value of the customies:rotation value that was defined in the returned block properties. Each permutation also contains a single minecraft:rotation component which rotates the block to the correct direction for the state. The condition string accepts molang expressions, as well as most entity queries . The different block components can also seen on bedrock.dev . public function getPermutations(): array { return [ (new Permutation(\"q.block_property('customies:rotation') == 2\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 0) ->setFloat(\"z\", 0)), (new Permutation(\"q.block_property('customies:rotation') == 3\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 180) ->setFloat(\"z\", 0)), (new Permutation(\"q.block_property('customies:rotation') == 4\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 90) ->setFloat(\"z\", 0)), (new Permutation(\"q.block_property('customies:rotation') == 5\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 270) ->setFloat(\"z\", 0)), ]; } getCurrentBlockProperties() In this method you must return an array of the server-side values which match the order and possible values of all the block properties for the block. In the example below, only the facing property from the trait is returned since it is the only block property. If the order of the values is incorrect, or invalid values are provided, runtime errors may occur when registering and using the blocks. public function getCurrentBlockProperties(): array { return [$this->facing]; } After you have implemented the Permutable interface, there are still a few more steps that you must complete before your block is usable. For pocketmine to be able to save and understand the different state, you must override the writeStateToMeta() , readStateFromData() & getStateBitmask() methods from the Block class. The first method requires translating the block properties in to a numeric meta value which pocketmine can understand. The Permutations::toMeta() method handles this conversion for you. The second method is used to load the block properties from the numeric meta value that was previously calculated. The Permutations::fromMeta() method handles the conversions for you, but you are still required to set the properties to the values from the returned array. The order of the returned properties will always be the same as the order of your defined block properties. The third and final method returns the highest bit required to represent all possible states of the block. The Permutations::getStateBitmask() method handles this calculation for you. protected function writeStateToMeta(): int { return Permutations::toMeta($this); } public function readStateFromData(int $id, int $stateMeta): void { $blockProperties = Permutations::fromMeta($this, $stateMeta); $this->facing = $blockProperties[0] ?? Facing::NORTH; } public function getStateBitmask(): int { return Permutations::getStateBitmask($this); } Using Permutations Using your new permutations is just as simple as changing the different values for each block property when appropriate. In the case of RotatableTrait , the facing property is set in the place() method of the block and is automatically placed using the correct rotation. This method is not a requirement, and the properties can be updated from anywhere and will still work when setting the block in the world. public function place(BlockTransaction $tx, Item $item, Block $blockReplace, Block $blockClicked, int $face, Vector3 $clickVector, ?Player $player = null): bool { if($player !== null) { $this->facing = $player->getHorizontalFacing(); } return parent::place($tx, $item, $blockReplace, $blockClicked, $face, $clickVector, $player); }","title":"Block Permutations"},{"location":"block_permutations/#block-permutations","text":"It is important to note that permutations are a very complex system, at least compared to the rest of the Customies API. For support with the Customies API, you can join our Discord .","title":"Block Permutations"},{"location":"block_permutations/#what-are-permutations","text":"In Minecraft, permutations are a way for a single block to behave different based on server-side data. Without permutations, a block can only have one possible state and behave similar to a dirt block. With permutations however, you can change the model or rotation of the same block to emulate the behaviour of a crop or a door etc.","title":"What are permutations?"},{"location":"block_permutations/#how-do-they-work","text":"When creating a block with permutations, there are two important sets of data that you must provide. The first is an array of block properties. Each block can have multiple block properties, and each one has a name and an array of all its possible values. The second set of data is an array of permutations which uses the block properties in molang queries to provide different block components for each different state. Both of these are sent to the client so it knows how to render every possible combination of the block.","title":"How do they work?"},{"location":"block_permutations/#rotating-blocks","text":"Customies includes a built-in RotatableTrait which can be used to implement horizontal rotations for your block. You do not need to write any extra code for it to function, and can easily be followed as an example of how permutations should be created. use customiesdevs\\customies\\block\\permutations\\Permutable; use customiesdevs\\customies\\block\\permutations\\RotatableTrait; use pocketmine\\block\\Opaque; class ExampleBlock extends Block implements Permutable { use RotatableTrait; }","title":"Rotating Blocks"},{"location":"block_permutations/#creating-your-own-permutations","text":"To get started with adding permutations to your block, you must first implement the Permutable interface. This interface requires you to implement all the methods necessary for permutations to function for a block. To help understand how permutations work, code from RotatableTrait will be used as examples.","title":"Creating Your Own Permutations"},{"location":"block_permutations/#getblockproperties","text":"In this method you must return an array of BlockProperty objects which can be used to determine the state of the block. In the example below, it is creating a property called customies:rotation with the possible values of [2, 3, 4, 5] . These numbers are the values from Facing::NORTH , Facing::SOUTH , Facing::WEST & Facing::EAST . The values do not need to be anything specific, and can use any primitive data type. public function getBlockProperties(): array { return [ new BlockProperty(\"customies:rotation\", [2, 3, 4, 5]), ]; }","title":"getBlockProperties()"},{"location":"block_permutations/#getpermutations","text":"In this method you must return an array of Permutation objects which can override different components based on a condition of the state. In the example below, there are four different permutations which all check for a different value of the customies:rotation value that was defined in the returned block properties. Each permutation also contains a single minecraft:rotation component which rotates the block to the correct direction for the state. The condition string accepts molang expressions, as well as most entity queries . The different block components can also seen on bedrock.dev . public function getPermutations(): array { return [ (new Permutation(\"q.block_property('customies:rotation') == 2\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 0) ->setFloat(\"z\", 0)), (new Permutation(\"q.block_property('customies:rotation') == 3\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 180) ->setFloat(\"z\", 0)), (new Permutation(\"q.block_property('customies:rotation') == 4\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 90) ->setFloat(\"z\", 0)), (new Permutation(\"q.block_property('customies:rotation') == 5\")) ->withComponent(\"minecraft:rotation\", CompoundTag::create() ->setFloat(\"x\", 0) ->setFloat(\"y\", 270) ->setFloat(\"z\", 0)), ]; }","title":"getPermutations()"},{"location":"block_permutations/#getcurrentblockproperties","text":"In this method you must return an array of the server-side values which match the order and possible values of all the block properties for the block. In the example below, only the facing property from the trait is returned since it is the only block property. If the order of the values is incorrect, or invalid values are provided, runtime errors may occur when registering and using the blocks. public function getCurrentBlockProperties(): array { return [$this->facing]; } After you have implemented the Permutable interface, there are still a few more steps that you must complete before your block is usable. For pocketmine to be able to save and understand the different state, you must override the writeStateToMeta() , readStateFromData() & getStateBitmask() methods from the Block class. The first method requires translating the block properties in to a numeric meta value which pocketmine can understand. The Permutations::toMeta() method handles this conversion for you. The second method is used to load the block properties from the numeric meta value that was previously calculated. The Permutations::fromMeta() method handles the conversions for you, but you are still required to set the properties to the values from the returned array. The order of the returned properties will always be the same as the order of your defined block properties. The third and final method returns the highest bit required to represent all possible states of the block. The Permutations::getStateBitmask() method handles this calculation for you. protected function writeStateToMeta(): int { return Permutations::toMeta($this); } public function readStateFromData(int $id, int $stateMeta): void { $blockProperties = Permutations::fromMeta($this, $stateMeta); $this->facing = $blockProperties[0] ?? Facing::NORTH; } public function getStateBitmask(): int { return Permutations::getStateBitmask($this); }","title":"getCurrentBlockProperties()"},{"location":"block_permutations/#using-permutations","text":"Using your new permutations is just as simple as changing the different values for each block property when appropriate. In the case of RotatableTrait , the facing property is set in the place() method of the block and is automatically placed using the correct rotation. This method is not a requirement, and the properties can be updated from anywhere and will still work when setting the block in the world. public function place(BlockTransaction $tx, Item $item, Block $blockReplace, Block $blockClicked, int $face, Vector3 $clickVector, ?Player $player = null): bool { if($player !== null) { $this->facing = $player->getHorizontalFacing(); } return parent::place($tx, $item, $blockReplace, $blockClicked, $face, $clickVector, $player); }","title":"Using Permutations"},{"location":"custom_block/","text":"Custom Block Guides Create Custom Block Here is an example how to create a custom block: use pocketmine\\block\\BlockBreakInfo; use pocketmine\\block\\BlockIdentifier; use pocketmine\\block\\Opaque; use pocketmine\\item\\Item; class CustomBlock extends Opaque{ public function __construct(string $name, BlockTypeInfo $typeInfo) { parent::__construct(new BlockIdentifier(BlockTypeIds::newId()), $name, $typeInfo); } } Basics Registering a custom block can either be done with or without a model using the CustomiesBlockFactory class. Without a model all you need to do is register the block by providing a Closure and the identifier of the block. The closure must be of the type Closure(int): Block , where the int is the ID that should be used for the block. This DOES NOT allow you to use a custom ID for the block, and will cause issues if you do not use the provided value. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { $hardeness = 0.3; $blockToolType = BlockToolType::PICKAXE; $blastResistance = 0.1; $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE); $identifier = \"customies:your_custom_block\"; CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo($hardeness, $blockToolType, 0, $blastResistance))), $identifier, null, $creativeInfo); // ... It is important to note that the provided closure is shared across threads, meaning you cannot use any variables that are not serializable types defined outside the scope of the closure. Getting a Block To get a custom block you need to use the CustomiesBlockFactory instead of the regular block factory so you can get the block from the custom identifier instead of a numeric id. $block = CustomiesBlockFactory::getInstance()->get(\"customies:example_block\"); Using Custom Models If your block contains a different model, you can provide a Model as the 5th argument. A model requires the following: - Materials: Array of materials that define how the texture is applied to specific faces - Texture: Name of the texture to apply to the model - Origin: The origin point of the selection box. Vector3(0, 0, 0) is the top right corner of the block - Size: The size of the block in pixels. This must be between Vector3(0, 0, 0) and Vector3(16, 16, 16) as the client does not support blocks being larger than this use customiesdevs\\customies\\block\\CustomiesBlockFactory; use customiesdevs\\customies\\block\\Material; use customiesdevs\\customies\\block\\Model; use pocketmine\\block\\BlockBreakInfo; use pocketmine\\math\\Vector3; // ... public function onEnable(): void { $material = new Material(Material::TARGET_ALL, \"example\", Material::RENDER_METHOD_ALPHA_TEST); $model = new Model([$material], \"geometry.example\", new Vector3(-8, 0, -8), new Vector3(16, 16, 16)); CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\"\", $model, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... More information about materials and the different properties can be found on docs.microsoft.com . Creative Inventory Try reading Item Creative Inventory it is the same concept. Updating from v1.0.7 -> newer versions In Customise v1.1.0, the method for registering custom blocks changed to be more dynamic and user friendly. Instead of providing the name and BlockBreakInfo to the registerBlock() method, you are now required to provide a Closure which returns a Block with the provided ID. Below is an example difference between the two versions for registering a custom block. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { - CustomiesBlockFactory::getInstance()->registerBlock(Block::class, \"customies:example_block\", \"Example Block\", new BlockBreakInfo(1)); + CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\"\", null, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... You can learn more about this change and why it was necessary here .","title":"Custom Block Guides"},{"location":"custom_block/#custom-block-guides","text":"","title":"Custom Block Guides"},{"location":"custom_block/#create-custom-block","text":"Here is an example how to create a custom block: use pocketmine\\block\\BlockBreakInfo; use pocketmine\\block\\BlockIdentifier; use pocketmine\\block\\Opaque; use pocketmine\\item\\Item; class CustomBlock extends Opaque{ public function __construct(string $name, BlockTypeInfo $typeInfo) { parent::__construct(new BlockIdentifier(BlockTypeIds::newId()), $name, $typeInfo); } }","title":"Create Custom Block"},{"location":"custom_block/#basics","text":"Registering a custom block can either be done with or without a model using the CustomiesBlockFactory class. Without a model all you need to do is register the block by providing a Closure and the identifier of the block. The closure must be of the type Closure(int): Block , where the int is the ID that should be used for the block. This DOES NOT allow you to use a custom ID for the block, and will cause issues if you do not use the provided value. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { $hardeness = 0.3; $blockToolType = BlockToolType::PICKAXE; $blastResistance = 0.1; $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE); $identifier = \"customies:your_custom_block\"; CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo($hardeness, $blockToolType, 0, $blastResistance))), $identifier, null, $creativeInfo); // ... It is important to note that the provided closure is shared across threads, meaning you cannot use any variables that are not serializable types defined outside the scope of the closure.","title":"Basics"},{"location":"custom_block/#getting-a-block","text":"To get a custom block you need to use the CustomiesBlockFactory instead of the regular block factory so you can get the block from the custom identifier instead of a numeric id. $block = CustomiesBlockFactory::getInstance()->get(\"customies:example_block\");","title":"Getting a Block"},{"location":"custom_block/#using-custom-models","text":"If your block contains a different model, you can provide a Model as the 5th argument. A model requires the following: - Materials: Array of materials that define how the texture is applied to specific faces - Texture: Name of the texture to apply to the model - Origin: The origin point of the selection box. Vector3(0, 0, 0) is the top right corner of the block - Size: The size of the block in pixels. This must be between Vector3(0, 0, 0) and Vector3(16, 16, 16) as the client does not support blocks being larger than this use customiesdevs\\customies\\block\\CustomiesBlockFactory; use customiesdevs\\customies\\block\\Material; use customiesdevs\\customies\\block\\Model; use pocketmine\\block\\BlockBreakInfo; use pocketmine\\math\\Vector3; // ... public function onEnable(): void { $material = new Material(Material::TARGET_ALL, \"example\", Material::RENDER_METHOD_ALPHA_TEST); $model = new Model([$material], \"geometry.example\", new Vector3(-8, 0, -8), new Vector3(16, 16, 16)); CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\"\", $model, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... More information about materials and the different properties can be found on docs.microsoft.com .","title":"Using Custom Models"},{"location":"custom_block/#creative-inventory","text":"Try reading Item Creative Inventory it is the same concept.","title":"Creative Inventory"},{"location":"custom_block/#updating-from-v107-newer-versions","text":"In Customise v1.1.0, the method for registering custom blocks changed to be more dynamic and user friendly. Instead of providing the name and BlockBreakInfo to the registerBlock() method, you are now required to provide a Closure which returns a Block with the provided ID. Below is an example difference between the two versions for registering a custom block. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { - CustomiesBlockFactory::getInstance()->registerBlock(Block::class, \"customies:example_block\", \"Example Block\", new BlockBreakInfo(1)); + CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\"\", null, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... You can learn more about this change and why it was necessary here .","title":"Updating from v1.0.7 -&gt; newer versions"},{"location":"custom_block_guides/","text":"Custom Block Guides Create Custom Block Here is an example how to create a custom block: use pocketmine\\block\\BlockBreakInfo; use pocketmine\\block\\BlockIdentifier; use pocketmine\\block\\Opaque; use pocketmine\\item\\Item; class CustomBlock extends Opaque{ public function __construct(string $name, BlockTypeInfo $typeInfo) { parent::__construct(new BlockIdentifier(BlockTypeIds::newId()), $name, $typeInfo); } } Basics Registering a custom block can either be done with or without a model using the CustomiesBlockFactory class. Without a model all you need to do is register the block by providing a Closure and the identifier of the block. The closure must be of the type Closure(int): Block , where the int is the ID that should be used for the block. This DOES NOT allow you to use a custom ID for the block, and will cause issues if you do not use the provided value. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { $hardeness = 0.3; $blockToolType = BlockToolType::PICKAXE; $blastResistance = 0.1; $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE); $identifier = \"customies:your_custom_block\"; CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo($hardeness, $blockToolType, 0, $blastResistance))), $identifier, null, $creativeInfo); } // ... It is important to note that the provided closure is shared across threads, meaning you cannot use any variables that are not serializable types defined outside the scope of the closure. Getting a Block To get a custom block you need to use the CustomiesBlockFactory instead of the regular block factory so you can get the block from the custom identifier instead of a numeric id. $block = CustomiesBlockFactory::getInstance()->get(\"customies:example_block\"); Using Custom Models If your block contains a different model, you can provide a Model as the 5th argument. A model requires the following: - Materials: Array of materials that define how the texture is applied to specific faces - Texture: Name of the texture to apply to the model - Origin: The origin point of the selection box. Vector3(0, 0, 0) is the top right corner of the block - Size: The size of the block in pixels. This must be between Vector3(0, 0, 0) and Vector3(16, 16, 16) as the client does not support blocks being larger than this use customiesdevs\\customies\\block\\CustomiesBlockFactory; use customiesdevs\\customies\\block\\Material; use customiesdevs\\customies\\block\\Model; use pocketmine\\block\\BlockBreakInfo; use pocketmine\\math\\Vector3; // ... public function onEnable(): void { $material = new Material(Material::TARGET_ALL, \"example\", Material::RENDER_METHOD_ALPHA_TEST); $model = new Model([$material], \"geometry.example\", new Vector3(-8, 0, -8), new Vector3(16, 16, 16)); CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\", $model, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... More information about materials and the different properties can be found on docs.microsoft.com . Creative Inventory Try reading Item Creative Inventory it is the same concept. Updating from v1.0.7 -> newer versions In Customise v1.1.0, the method for registering custom blocks changed to be more dynamic and user friendly. Instead of providing the name and BlockBreakInfo to the registerBlock() method, you are now required to provide a Closure which returns a Block with the provided ID. Below is an example difference between the two versions for registering a custom block. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { - CustomiesBlockFactory::getInstance()->registerBlock(Block::class, \"customies:example_block\", \"Example Block\", new BlockBreakInfo(1)); + CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\"\", null, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... You can learn more about this change and why it was necessary here .","title":"Custom Block Guides"},{"location":"custom_block_guides/#custom-block-guides","text":"","title":"Custom Block Guides"},{"location":"custom_block_guides/#create-custom-block","text":"Here is an example how to create a custom block: use pocketmine\\block\\BlockBreakInfo; use pocketmine\\block\\BlockIdentifier; use pocketmine\\block\\Opaque; use pocketmine\\item\\Item; class CustomBlock extends Opaque{ public function __construct(string $name, BlockTypeInfo $typeInfo) { parent::__construct(new BlockIdentifier(BlockTypeIds::newId()), $name, $typeInfo); } }","title":"Create Custom Block"},{"location":"custom_block_guides/#basics","text":"Registering a custom block can either be done with or without a model using the CustomiesBlockFactory class. Without a model all you need to do is register the block by providing a Closure and the identifier of the block. The closure must be of the type Closure(int): Block , where the int is the ID that should be used for the block. This DOES NOT allow you to use a custom ID for the block, and will cause issues if you do not use the provided value. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { $hardeness = 0.3; $blockToolType = BlockToolType::PICKAXE; $blastResistance = 0.1; $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE); $identifier = \"customies:your_custom_block\"; CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo($hardeness, $blockToolType, 0, $blastResistance))), $identifier, null, $creativeInfo); } // ... It is important to note that the provided closure is shared across threads, meaning you cannot use any variables that are not serializable types defined outside the scope of the closure.","title":"Basics"},{"location":"custom_block_guides/#getting-a-block","text":"To get a custom block you need to use the CustomiesBlockFactory instead of the regular block factory so you can get the block from the custom identifier instead of a numeric id. $block = CustomiesBlockFactory::getInstance()->get(\"customies:example_block\");","title":"Getting a Block"},{"location":"custom_block_guides/#using-custom-models","text":"If your block contains a different model, you can provide a Model as the 5th argument. A model requires the following: - Materials: Array of materials that define how the texture is applied to specific faces - Texture: Name of the texture to apply to the model - Origin: The origin point of the selection box. Vector3(0, 0, 0) is the top right corner of the block - Size: The size of the block in pixels. This must be between Vector3(0, 0, 0) and Vector3(16, 16, 16) as the client does not support blocks being larger than this use customiesdevs\\customies\\block\\CustomiesBlockFactory; use customiesdevs\\customies\\block\\Material; use customiesdevs\\customies\\block\\Model; use pocketmine\\block\\BlockBreakInfo; use pocketmine\\math\\Vector3; // ... public function onEnable(): void { $material = new Material(Material::TARGET_ALL, \"example\", Material::RENDER_METHOD_ALPHA_TEST); $model = new Model([$material], \"geometry.example\", new Vector3(-8, 0, -8), new Vector3(16, 16, 16)); CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\", $model, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... More information about materials and the different properties can be found on docs.microsoft.com .","title":"Using Custom Models"},{"location":"custom_block_guides/#creative-inventory","text":"Try reading Item Creative Inventory it is the same concept.","title":"Creative Inventory"},{"location":"custom_block_guides/#updating-from-v107-newer-versions","text":"In Customise v1.1.0, the method for registering custom blocks changed to be more dynamic and user friendly. Instead of providing the name and BlockBreakInfo to the registerBlock() method, you are now required to provide a Closure which returns a Block with the provided ID. Below is an example difference between the two versions for registering a custom block. use customiesdevs\\customies\\block\\CustomiesBlockFactory; use pocketmine\\block\\BlockBreakInfo; // ... public function onEnable(): void { - CustomiesBlockFactory::getInstance()->registerBlock(Block::class, \"customies:example_block\", \"Example Block\", new BlockBreakInfo(1)); + CustomiesBlockFactory::getInstance()->registerBlock(static fn () => new CustomBlock(\"your_name_here\", new BlockTypeInfo(new BlockBreakInfo(0.3, BlockToolType::PICKAXE, 0, 0.1))), \"customies:your_custom_block\"\", null, new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_CONSTRUCTION, CreativeInventoryInfo::NONE)); } // ... You can learn more about this change and why it was necessary here .","title":"Updating from v1.0.7 -&gt; newer versions"},{"location":"custom_entity/","text":"Custom Entity Guides Custom Entity Class Before you can register an entity, you need to create a class extending Entity that uses your custom identifier. This is required for pocketmine to know the type of entity to spawn. use pocketmine\\entity\\Entity; class ExampleEntity extends Entity { // ... public static function getNetworkTypeId(): string { return \"customies:example_entity\"; } // ... } Registering an Entity Registering a custom entity is as simple as registering a normal entity. All you need to do is use the CustomiesEntityFactory class to register the entity and use the same identifier from the previous step. use customiesdevs\\customies\\entity\\CustomiesEntityFactory; // ... public function onEnable(): void { CustomiesEntityFactory::getInstance()->registerEntity(ExampleEntity::class, \"customies:example_entity\"); } // ... If you want to provide your own creation function, you can provide a Closure(World $world, CompoundTag $nbt): Entity as the 3rd argument. Creating an Entity Creating a custom entity is identical to how you would do it normally with any other entity, and the same applies for spawning it. $entity = new ExampleEntity(...); $entity->spawnToAll();","title":"Custom Entity Guides"},{"location":"custom_entity/#custom-entity-guides","text":"","title":"Custom Entity Guides"},{"location":"custom_entity/#custom-entity-class","text":"Before you can register an entity, you need to create a class extending Entity that uses your custom identifier. This is required for pocketmine to know the type of entity to spawn. use pocketmine\\entity\\Entity; class ExampleEntity extends Entity { // ... public static function getNetworkTypeId(): string { return \"customies:example_entity\"; } // ... }","title":"Custom Entity Class"},{"location":"custom_entity/#registering-an-entity","text":"Registering a custom entity is as simple as registering a normal entity. All you need to do is use the CustomiesEntityFactory class to register the entity and use the same identifier from the previous step. use customiesdevs\\customies\\entity\\CustomiesEntityFactory; // ... public function onEnable(): void { CustomiesEntityFactory::getInstance()->registerEntity(ExampleEntity::class, \"customies:example_entity\"); } // ... If you want to provide your own creation function, you can provide a Closure(World $world, CompoundTag $nbt): Entity as the 3rd argument.","title":"Registering an Entity"},{"location":"custom_entity/#creating-an-entity","text":"Creating a custom entity is identical to how you would do it normally with any other entity, and the same applies for spawning it. $entity = new ExampleEntity(...); $entity->spawnToAll();","title":"Creating an Entity"},{"location":"custom_entity_guides/","text":"Custom Entity Guides Custom Entity Class Before you can register an entity, you need to create a class extending Entity that uses your custom identifier. This is required for pocketmine to know the type of entity to spawn. use pocketmine\\entity\\Entity; class ExampleEntity extends Entity { // ... public static function getNetworkTypeId(): string { return \"customies:example_entity\"; } // ... } Registering an Entity Registering a custom entity is as simple as registering a normal entity. All you need to do is use the CustomiesEntityFactory class to register the entity and use the same identifier from the previous step. use customiesdevs\\customies\\entity\\CustomiesEntityFactory; // ... public function onEnable(): void { CustomiesEntityFactory::getInstance()->registerEntity(ExampleEntity::class, \"customies:example_entity\"); } // ... If you want to provide your own creation function, you can provide a Closure(World $world, CompoundTag $nbt): Entity as the 3rd argument. Creating an Entity Creating a custom entity is identical to how you would do it normally with any other entity, and the same applies for spawning it. $entity = new ExampleEntity(...); $entity->spawnToAll();","title":"Custom Entity Guides"},{"location":"custom_entity_guides/#custom-entity-guides","text":"","title":"Custom Entity Guides"},{"location":"custom_entity_guides/#custom-entity-class","text":"Before you can register an entity, you need to create a class extending Entity that uses your custom identifier. This is required for pocketmine to know the type of entity to spawn. use pocketmine\\entity\\Entity; class ExampleEntity extends Entity { // ... public static function getNetworkTypeId(): string { return \"customies:example_entity\"; } // ... }","title":"Custom Entity Class"},{"location":"custom_entity_guides/#registering-an-entity","text":"Registering a custom entity is as simple as registering a normal entity. All you need to do is use the CustomiesEntityFactory class to register the entity and use the same identifier from the previous step. use customiesdevs\\customies\\entity\\CustomiesEntityFactory; // ... public function onEnable(): void { CustomiesEntityFactory::getInstance()->registerEntity(ExampleEntity::class, \"customies:example_entity\"); } // ... If you want to provide your own creation function, you can provide a Closure(World $world, CompoundTag $nbt): Entity as the 3rd argument.","title":"Registering an Entity"},{"location":"custom_entity_guides/#creating-an-entity","text":"Creating a custom entity is identical to how you would do it normally with any other entity, and the same applies for spawning it. $entity = new ExampleEntity(...); $entity->spawnToAll();","title":"Creating an Entity"},{"location":"custom_item/","text":"Custom Item Guides Registering an Item Registering a custom item is as simple as registering a normal item, but the ID is calculated for you. All you need to do is use the CustomiesItemFactory class to register the item, and fetch it as you would with a vanilla item. use customiesdevs\\customies\\item\\CustomiesItemFactory; // ... public function onEnable(): void { CustomiesItemFactory::getInstance()->registerItem(Item::class, \"customies:example_item\", \"Example Item\"); } // ... Getting an Item To get a custom item you need to use the CustomiesItemFactory instead of the regular item factory so you can get the item from the custom identifier instead of needing a numeric id. $item = CustomiesItemFactory::getInstance()->get(\"customies:example_item\"); Item Components Custom items can also have components which are used to change the behaviour of items client side, such as making it edible or have durability etc. To get started with components, you need to implement the ItemComponents interface, use the ItemComponentsTrait and call the initComponent method in the constructor of your class. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct() { parent::__construct(new ItemIdentifier(ItemTypeIds::newId()), \"your_name_here\", []); $this->initComponent(\"your_texture_here\", new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_ITEMS)); } } Now that you have an item with components, you can add either components or properties using the addComponent and addProperty methods (after initializing the item). // ... + $this->addComponent(new DurabilityComponent(3000)) + $this->addComponent(new MaxStackSizeComponent(1)); + $this->addComponent(new AllowOffHandComponent(false)); - $this->addProperty(\"allow_off_hand\", false) - $this->addComponent(\"minecraft:armor\", [\"protection\" => new IntTag(4)]); // ... More information about all the different item components and properties can be found on docs.microsoft.com . Creative Inventory If you want add the item to the creative inventory, you can provide a CreativeInventoryInfo as the 3th argument to initComponent . This contains the following: - Category: The base category to show the item in, for example CreativeInventoryInfo::CATEGORY_EQUIPMENT will put the item in the equipment category - Group: The group to put the item in inside of the category, for example CreativeInventoryInfo::GROUP_SWORD will put the item at the end of the sword group use customiesdevs\\customies\\item\\CreativeInventoryInfo; // ... $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_EQUIPMENT, CreativeInventoryInfo::GROUP_SWORD); $this->initComponent(\"your_texture_here\", $creativeInfo); // ... More information about creative categories and groups can be found on docs.microsoft.com . Regulating Held Item Scale If you are using a custom item that has a texture larger than 16x16 pixels, you may notice the scale of the item also increases when held in a player's hand. To solve this you can use the setupRenderOffsets() method inside the ItemComponentsTrait . This requires the initComponent() method to first be called. The method accepts two integers for the width and height of the image, and an optional bool for if the item is hand equipped, e.g. a sword/tool. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct(ItemIdentifier $idInfo) { parent::__construct($idInfo); $this->initComponent(\"your_texture_here\"); $this->setupRenderOffsets(32, 32, true); } }","title":"Custom Item Guides"},{"location":"custom_item/#custom-item-guides","text":"","title":"Custom Item Guides"},{"location":"custom_item/#registering-an-item","text":"Registering a custom item is as simple as registering a normal item, but the ID is calculated for you. All you need to do is use the CustomiesItemFactory class to register the item, and fetch it as you would with a vanilla item. use customiesdevs\\customies\\item\\CustomiesItemFactory; // ... public function onEnable(): void { CustomiesItemFactory::getInstance()->registerItem(Item::class, \"customies:example_item\", \"Example Item\"); } // ...","title":"Registering an Item"},{"location":"custom_item/#getting-an-item","text":"To get a custom item you need to use the CustomiesItemFactory instead of the regular item factory so you can get the item from the custom identifier instead of needing a numeric id. $item = CustomiesItemFactory::getInstance()->get(\"customies:example_item\");","title":"Getting an Item"},{"location":"custom_item/#item-components","text":"Custom items can also have components which are used to change the behaviour of items client side, such as making it edible or have durability etc. To get started with components, you need to implement the ItemComponents interface, use the ItemComponentsTrait and call the initComponent method in the constructor of your class. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct() { parent::__construct(new ItemIdentifier(ItemTypeIds::newId()), \"your_name_here\", []); $this->initComponent(\"your_texture_here\", new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_ITEMS)); } } Now that you have an item with components, you can add either components or properties using the addComponent and addProperty methods (after initializing the item). // ... + $this->addComponent(new DurabilityComponent(3000)) + $this->addComponent(new MaxStackSizeComponent(1)); + $this->addComponent(new AllowOffHandComponent(false)); - $this->addProperty(\"allow_off_hand\", false) - $this->addComponent(\"minecraft:armor\", [\"protection\" => new IntTag(4)]); // ... More information about all the different item components and properties can be found on docs.microsoft.com .","title":"Item Components"},{"location":"custom_item/#creative-inventory","text":"If you want add the item to the creative inventory, you can provide a CreativeInventoryInfo as the 3th argument to initComponent . This contains the following: - Category: The base category to show the item in, for example CreativeInventoryInfo::CATEGORY_EQUIPMENT will put the item in the equipment category - Group: The group to put the item in inside of the category, for example CreativeInventoryInfo::GROUP_SWORD will put the item at the end of the sword group use customiesdevs\\customies\\item\\CreativeInventoryInfo; // ... $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_EQUIPMENT, CreativeInventoryInfo::GROUP_SWORD); $this->initComponent(\"your_texture_here\", $creativeInfo); // ... More information about creative categories and groups can be found on docs.microsoft.com .","title":"Creative Inventory"},{"location":"custom_item/#regulating-held-item-scale","text":"If you are using a custom item that has a texture larger than 16x16 pixels, you may notice the scale of the item also increases when held in a player's hand. To solve this you can use the setupRenderOffsets() method inside the ItemComponentsTrait . This requires the initComponent() method to first be called. The method accepts two integers for the width and height of the image, and an optional bool for if the item is hand equipped, e.g. a sword/tool. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct(ItemIdentifier $idInfo) { parent::__construct($idInfo); $this->initComponent(\"your_texture_here\"); $this->setupRenderOffsets(32, 32, true); } }","title":"Regulating Held Item Scale"},{"location":"custom_item_guides/","text":"Custom Item Guides Registering an Item Registering a custom item is as simple as registering a normal item, but the ID is calculated for you. All you need to do is use the CustomiesItemFactory class to register the item, and fetch it as you would with a vanilla item. use customiesdevs\\customies\\item\\CustomiesItemFactory; // ... public function onEnable(): void { CustomiesItemFactory::getInstance()->registerItem(Item::class, \"customies:example_item\", \"Example Item\"); } // ... Getting an Item To get a custom item you need to use the CustomiesItemFactory instead of the regular item factory so you can get the item from the custom identifier instead of needing a numeric id. $item = CustomiesItemFactory::getInstance()->get(\"customies:example_item\"); Item Components Custom items can also have components which are used to change the behaviour of items client side, such as making it edible or have durability etc. To get started with components, you need to implement the ItemComponents interface, use the ItemComponentsTrait and call the initComponent method in the constructor of your class. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct() { parent::__construct(new ItemIdentifier(ItemTypeIds::newId()), \"your_name_here\", []); $this->initComponent(\"your_texture_here\", new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_ITEMS)); } } Now that you have an item with components, you can add either components or properties using the addComponent and addProperty methods (after initializing the item). // ... + $this->addComponent(new DurabilityComponent(3000)) + $this->addComponent(new MaxStackSizeComponent(1)); + $this->addComponent(new AllowOffHandComponent(false)); - $this->addProperty(\"allow_off_hand\", false) - $this->addComponent(\"minecraft:armor\", [\"protection\" => new IntTag(4)]); // ... More information about all the different item components and properties can be found on docs.microsoft.com . Creative Inventory If you want add the item to the creative inventory, you can provide a CreativeInventoryInfo as the 3th argument to initComponent . This contains the following: - Category: The base category to show the item in, for example CreativeInventoryInfo::CATEGORY_EQUIPMENT will put the item in the equipment category - Group: The group to put the item in inside of the category, for example CreativeInventoryInfo::GROUP_SWORD will put the item at the end of the sword group use customiesdevs\\customies\\item\\CreativeInventoryInfo; // ... $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_EQUIPMENT, CreativeInventoryInfo::GROUP_SWORD); $this->initComponent(\"your_texture_here\", $creativeInfo); // ... More information about creative categories and groups can be found on docs.microsoft.com . Regulating Held Item Scale If you are using a custom item that has a texture larger than 16x16 pixels, you may notice the scale of the item also increases when held in a player's hand. To solve this you can use the setupRenderOffsets() method inside the ItemComponentsTrait . This requires the initComponent() method to first be called. The method accepts two integers for the width and height of the image, and an optional bool for if the item is hand equipped, e.g. a sword/tool. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct(ItemIdentifier $idInfo) { parent::__construct($idInfo); $this->initComponent(\"your_texture_here\"); $this->setupRenderOffsets(32, 32, true); } }","title":"Custom Item Guides"},{"location":"custom_item_guides/#custom-item-guides","text":"","title":"Custom Item Guides"},{"location":"custom_item_guides/#registering-an-item","text":"Registering a custom item is as simple as registering a normal item, but the ID is calculated for you. All you need to do is use the CustomiesItemFactory class to register the item, and fetch it as you would with a vanilla item. use customiesdevs\\customies\\item\\CustomiesItemFactory; // ... public function onEnable(): void { CustomiesItemFactory::getInstance()->registerItem(Item::class, \"customies:example_item\", \"Example Item\"); } // ...","title":"Registering an Item"},{"location":"custom_item_guides/#getting-an-item","text":"To get a custom item you need to use the CustomiesItemFactory instead of the regular item factory so you can get the item from the custom identifier instead of needing a numeric id. $item = CustomiesItemFactory::getInstance()->get(\"customies:example_item\");","title":"Getting an Item"},{"location":"custom_item_guides/#item-components","text":"Custom items can also have components which are used to change the behaviour of items client side, such as making it edible or have durability etc. To get started with components, you need to implement the ItemComponents interface, use the ItemComponentsTrait and call the initComponent method in the constructor of your class. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct() { parent::__construct(new ItemIdentifier(ItemTypeIds::newId()), \"your_name_here\", []); $this->initComponent(\"your_texture_here\", new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_ITEMS)); } } Now that you have an item with components, you can add either components or properties using the addComponent and addProperty methods (after initializing the item). // ... + $this->addComponent(new DurabilityComponent(3000)) + $this->addComponent(new MaxStackSizeComponent(1)); + $this->addComponent(new AllowOffHandComponent(false)); - $this->addProperty(\"allow_off_hand\", false) - $this->addComponent(\"minecraft:armor\", [\"protection\" => new IntTag(4)]); // ... More information about all the different item components and properties can be found on docs.microsoft.com .","title":"Item Components"},{"location":"custom_item_guides/#creative-inventory","text":"If you want add the item to the creative inventory, you can provide a CreativeInventoryInfo as the 3th argument to initComponent . This contains the following: - Category: The base category to show the item in, for example CreativeInventoryInfo::CATEGORY_EQUIPMENT will put the item in the equipment category - Group: The group to put the item in inside of the category, for example CreativeInventoryInfo::GROUP_SWORD will put the item at the end of the sword group use customiesdevs\\customies\\item\\CreativeInventoryInfo; // ... $creativeInfo = new CreativeInventoryInfo(CreativeInventoryInfo::CATEGORY_EQUIPMENT, CreativeInventoryInfo::GROUP_SWORD); $this->initComponent(\"your_texture_here\", $creativeInfo); // ... More information about creative categories and groups can be found on docs.microsoft.com .","title":"Creative Inventory"},{"location":"custom_item_guides/#regulating-held-item-scale","text":"If you are using a custom item that has a texture larger than 16x16 pixels, you may notice the scale of the item also increases when held in a player's hand. To solve this you can use the setupRenderOffsets() method inside the ItemComponentsTrait . This requires the initComponent() method to first be called. The method accepts two integers for the width and height of the image, and an optional bool for if the item is hand equipped, e.g. a sword/tool. use customiesdevs\\customies\\item\\ItemComponents; use customiesdevs\\customies\\item\\ItemComponentsTrait; use pocketmine\\item\\Item; class ExampleItem extends Item implements ItemComponents { use ItemComponentsTrait; public function __construct(ItemIdentifier $idInfo) { parent::__construct($idInfo); $this->initComponent(\"your_texture_here\"); $this->setupRenderOffsets(32, 32, true); } }","title":"Regulating Held Item Scale"}]}